name: Unified Release Build

on:
  push:
    branches: [main, develop]
    tags: ["v*"]
  pull_request:
    branches: [main]
    paths:
      - "shared/**"
      - "desktop/**"
      - "mobile/**"
      - "scripts/build/**"
      - ".github/docker/**"
      - ".github/workflows/unified-release.yml"
      - "Cargo.toml"
      - "Cargo.lock"
  workflow_dispatch:

permissions:
  contents: write
  packages: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Test and build all components once
  test-and-build:
    name: Test and Build All Platforms
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.version.outputs.VERSION }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy
        continue-on-error: true
        id: rust-install

      - name: Manual Rust installation (fallback)
        if: steps.rust-install.outcome == 'failure'
        run: |
          curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \
            --default-toolchain stable \
            --component rustfmt,clippy
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          source $HOME/.cargo/env

      - name: Setup Rust environment
        run: |
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
          rustc --version
          cargo --version

      - name: Cache cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-unified-cargo-${{ hashFiles('**/Cargo.lock') }}-${{ hashFiles('**/*.rs') }}
          restore-keys: |
            ${{ runner.os }}-unified-cargo-${{ hashFiles('**/Cargo.lock') }}-
            ${{ runner.os }}-unified-cargo-

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            libfontconfig1-dev \
            libfreetype6-dev \
            libx11-dev \
            libxft-dev \
            liblzma-dev \
            libgtk-4-dev \
            libadwaita-1-dev \
            libatk1.0-dev \
            libatk-bridge2.0-dev \
            libgtk-3-dev \
            libgdk-pixbuf-2.0-dev \
            libglib2.0-dev \
            libcairo2-dev \
            libpango1.0-dev

      - name: Verify GTK4 installation
        run: |
          pkg-config --exists gtk4 || {
            echo "GTK4 not found, attempting alternative installation"
            exit 1
          }
          pkg-config --modversion gtk4

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Run clippy
        run: |
          # Run clippy on shared library
          cargo clippy -p ziplock-shared --all-targets -- \
            -D warnings -A clippy::uninlined-format-args -A unused-imports -A dead-code -A clippy::not-unsafe-ptr-arg-deref -A clippy::should-implement-trait -A unused-unsafe -A clippy::collapsible-str-replace -A clippy::new-without-default -A clippy::let-and-return -A clippy::needless-borrows-for-generic-args -A clippy::needless-range-loop -A clippy::unnecessary-map-or -A clippy::collapsible-if -A clippy::needless-late-init -A clippy::unnecessary-cast -A clippy::needless-borrow -A clippy::field-reassign-with-default -A clippy::overly-complex-bool-expr -A clippy::for-kv-map -A unused-variables -A unused-must-use -A clippy::useless-format -A clippy::items-after-test-module

          # Run clippy on unified application (iced-gui features only)
          cargo clippy -p ziplock-desktop --no-default-features --features "iced-gui,wayland-support,file-dialog" --all-targets -- \
            -D warnings -A clippy::uninlined-format-args -A unused-imports -A dead-code -A clippy::not-unsafe-ptr-arg-deref -A clippy::should-implement-trait -A unused-unsafe -A clippy::collapsible-str-replace -A clippy::new-without-default -A clippy::let-and-return -A clippy::needless-borrows-for-generic-args -A clippy::needless-range-loop -A clippy::unnecessary-map-or -A clippy::collapsible-if -A clippy::needless-late-init -A clippy::unnecessary-cast -A clippy::needless-borrow -A clippy::field-reassign-with-default -A clippy::overly-complex-bool-expr -A clippy::for-kv-map -A unused-variables -A unused-must-use -A clippy::useless-format -A clippy::items-after-test-module

      - name: Run tests
        run: |
          cargo test --workspace --all-features

      - name: Build Linux binaries
        run: |
          # Build the ziplock binary from the desktop app workspace member
          cargo build --release --bin ziplock -p ziplock-desktop

          # Create output directory structure
          mkdir -p target/artifacts/linux/binaries
          cp target/release/ziplock target/artifacts/linux/binaries/

          # Make binaries executable
          chmod +x target/artifacts/linux/binaries/*

      - name: Extract version
        id: version
        run: |
          VERSION=$(grep '^version' Cargo.toml | head -1 | sed -n 's/.*"\(.*\)".*/\1/p')
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "Detected version: $VERSION"

      - name: Upload Linux build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-binaries
          path: target/artifacts/linux/
          retention-days: 30

  # Security audit
  security-audit:
    name: Security Audit
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo-audit
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/cargo-audit
          key: cargo-audit-${{ runner.os }}

      - name: Install cargo-audit
        run: |
          if ! command -v cargo-audit &> /dev/null; then
            cargo install cargo-audit
          fi

      - name: Run security audit
        run: cargo audit

  # Build Android libraries
  build-android:
    name: Build Android Libraries and APK
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/ejangi/ziplock/android-builder:latest
      options: --pull always

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust toolchain and Android environment
        run: |
          # Find and set Java 17 path
          JAVA17_HOME=$(find /usr/lib/jvm -name "java-17-openjdk*" -type d | head -1)
          if [ -z "$JAVA17_HOME" ]; then
            echo "Java 17 not found, checking available Java versions:"
            ls -la /usr/lib/jvm/
            exit 1
          fi

          export JAVA_HOME="$JAVA17_HOME"
          export PATH="$JAVA_HOME/bin:$PATH"
          echo "JAVA_HOME=$JAVA_HOME" >> $GITHUB_ENV
          echo "$JAVA_HOME/bin" >> $GITHUB_PATH

          # Verify Java version
          java -version
          echo "Using Java from: $(which java)"
          echo "JAVA_HOME set to: $JAVA_HOME"

          rustup default stable
          rustup update

          # Install Android targets
          rustup target add aarch64-linux-android
          rustup target add armv7-linux-androideabi
          rustup target add x86_64-linux-android
          rustup target add i686-linux-android

          # Note: Using direct cargo build instead of cargo-ndk to handle cdylib issues

          # Verify Android NDK is available
          if [ -n "$ANDROID_NDK_HOME" ]; then
            echo "Android NDK found at: $ANDROID_NDK_HOME"
            export NDK_HOME="$ANDROID_NDK_HOME"
          elif [ -n "$NDK_HOME" ]; then
            export ANDROID_NDK_HOME="$NDK_HOME"
            echo "Android NDK found at: $ANDROID_NDK_HOME"
          else
            echo "Warning: Android NDK environment variables not set"
            # Try to find NDK in common locations
            for ndk_path in /opt/android-ndk* /usr/local/lib/android/sdk/ndk/*; do
              if [ -d "$ndk_path" ]; then
                export ANDROID_NDK_HOME="$ndk_path"
                export NDK_HOME="$ndk_path"
                echo "Found NDK at: $ANDROID_NDK_HOME"
                break
              fi
            done
          fi

          # Verify NDK tools are available
          if [ -n "$ANDROID_NDK_HOME" ]; then
            echo "Verifying NDK tools..."
            ls -la "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/" | head -5

            # Test cross-compilation tools
            if [ -f "$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang" ]; then
              echo "✓ Android cross-compilation tools found"
            else
              echo "✗ Android cross-compilation tools not found"
            fi
          fi

      - name: Build Android libraries
        shell: bash
        run: |
          cd shared

          # Debug: Check what targets are available
          echo "=== Available Rust targets ==="
          rustup target list --installed | grep android

          # Debug: Check NDK setup
          echo "=== NDK Configuration ==="
          echo "ANDROID_NDK_HOME: $ANDROID_NDK_HOME"
          echo "NDK_HOME: $NDK_HOME"

          # Set up environment for direct cargo build
          export CC_aarch64_linux_android="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang"
          export CC_armv7_linux_androideabi="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/armv7a-linux-androideabi21-clang"
          export CC_x86_64_linux_android="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/x86_64-linux-android21-clang"
          export CC_i686_linux_android="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/i686-linux-android21-clang"

          export AR_aarch64_linux_android="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
          export AR_armv7_linux_androideabi="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
          export AR_x86_64_linux_android="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"
          export AR_i686_linux_android="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/llvm-ar"

          # Build for each target with proper environment
          echo "=== Building for Android targets ==="

          targets=("aarch64-linux-android" "armv7-linux-androideabi" "x86_64-linux-android" "i686-linux-android")

          for target in "${targets[@]}"; do
            echo "Building for $target..."
            RUSTFLAGS="-C link-arg=-static-libgcc -C link-arg=-Wl,--as-needed" \
              cargo build --release --target $target --lib --features c-api

            # Check what was built
            echo "Checking build output for $target:"
            if ls "/workspace/target/$target/release/"*ziplock* 1> /dev/null 2>&1; then
              echo "✓ Build artifacts found for $target"
            else
              echo "⚠ No build artifacts found for $target"
            fi
          done

          # Create output structure
          mkdir -p ../target/android/jniLibs/{arm64-v8a,armeabi-v7a,x86_64,x86}

          # Copy built libraries with fallback handling
          echo "=== Copying libraries ==="

          # Helper function to find and copy library
          copy_library() {
            local target=$1
            local arch_dir=$2
            local cc_var=$3

            # Check both possible paths
            local lib_path=""
            if [ -f "../target/$target/release/libziplock_shared.so" ]; then
              lib_path="../target/$target/release/libziplock_shared.so"
            elif [ -f "/workspace/target/$target/release/libziplock_shared.so" ]; then
              lib_path="/workspace/target/$target/release/libziplock_shared.so"
            fi

            if [ -n "$lib_path" ]; then
              cp "$lib_path" "../target/android/jniLibs/$arch_dir/"
              echo "✓ Copied $target library from $lib_path"
              return 0
            fi

            # Try static library fallback
            local static_path=""
            if [ -f "../target/$target/release/libziplock_shared.a" ]; then
              static_path="../target/$target/release/libziplock_shared.a"
            elif [ -f "/workspace/target/$target/release/libziplock_shared.a" ]; then
              static_path="/workspace/target/$target/release/libziplock_shared.a"
            fi

            if [ -n "$static_path" ]; then
              echo "⚠ $target cdylib was dropped, using rlib approach"
              eval \$$cc_var -shared -o "../target/android/jniLibs/$arch_dir/libziplock_shared.so" \
                -Wl,--whole-archive "$static_path" -Wl,--no-whole-archive
              echo "✓ Created $target shared library from static library"
              return 0
            fi

            echo "✗ $target library not found in either path"
            return 1
          }

          # Copy libraries for each architecture
          copy_library "aarch64-linux-android" "arm64-v8a" "CC_aarch64_linux_android" || exit 1
          copy_library "armv7-linux-androideabi" "armeabi-v7a" "CC_armv7_linux_androideabi" || exit 1
          copy_library "x86_64-linux-android" "x86_64" "CC_x86_64_linux_android" || exit 1
          copy_library "i686-linux-android" "x86" "CC_i686_linux_android" || exit 1

          # Copy to Android app directory if it exists
          if [ -d "../apps/mobile/android/app/src/main" ]; then
            mkdir -p ../apps/mobile/android/app/src/main/jniLibs/{arm64-v8a,armeabi-v7a,x86_64,x86}
            cp -r ../target/android/jniLibs/* ../apps/mobile/android/app/src/main/jniLibs/
            echo "Libraries copied to Android app jniLibs"
          fi

      - name: Test Android libraries
        shell: bash
        run: |
          echo "Testing Android library outputs..."
          for arch in arm64-v8a armeabi-v7a x86_64 x86; do
            lib_path="target/android/jniLibs/$arch/libziplock_shared.so"
            if [ -f "$lib_path" ]; then
              echo "✓ Found library: $arch"
              echo "  Size: $(stat -c%s "$lib_path") bytes"
              echo "  Type: $(file "$lib_path" | cut -d: -f2-)"

              # Check for key symbols
              if readelf -s "$lib_path" | grep -q "ziplock_"; then
                echo "  ✓ Contains ziplock symbols"
              else
                echo "  ⚠ No ziplock symbols found"
              fi
            else
              echo "✗ Missing library: $arch"
            fi
            echo
          done

      - name: Build Android APK
        shell: bash
        run: |
          echo "Building Android APK..."

          # Find and set Java 17 path
          JAVA17_HOME=$(find /usr/lib/jvm -name "java-17-openjdk*" -type d | head -1)
          if [ -z "$JAVA17_HOME" ]; then
            echo "Java 17 not found, checking available Java versions:"
            ls -la /usr/lib/jvm/
            exit 1
          fi

          export JAVA_HOME="$JAVA17_HOME"
          export PATH="$JAVA_HOME/bin:$PATH"

          # Set up Android SDK environment
          export ANDROID_HOME="/opt/android-sdk"
          export ANDROID_SDK_ROOT="$ANDROID_HOME"
          export PATH="$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/platform-tools:$PATH"

          # Verify environment setup
          echo "Java version for Gradle:"
          java -version
          echo "JAVA_HOME: $JAVA_HOME"
          echo "ANDROID_HOME: $ANDROID_HOME"
          echo "Android SDK version:"
          sdkmanager --version || echo "SDK manager not available"

          cd apps/mobile/android

          # Ensure native libraries are in the correct location
          if [ -d "../../../target/android/jniLibs" ]; then
            mkdir -p app/src/main/jniLibs
            cp -r ../../../target/android/jniLibs/* app/src/main/jniLibs/
            echo "✓ Native libraries copied to Android project"
          else
            echo "⚠ Warning: No native libraries found, APK will be built without native components"
          fi

          # List what we have in jniLibs
          echo "Native libraries in jniLibs:"
          find app/src/main/jniLibs -name "*.so" 2>/dev/null || echo "No .so files found"

          # Make gradlew executable
          chmod +x gradlew

          # Build release APK with explicit properties and increased memory
          echo "Building release APK..."
          ./gradlew assembleRelease \
            -Dorg.gradle.java.home="$JAVA_HOME" \
            -Dorg.gradle.jvmargs="-Xmx6144m -XX:MaxMetaspaceSize=1024m -XX:+UseG1GC" \
            -Pandroid.useAndroidX=true \
            -Pandroid.enableJetifier=true \
            --no-daemon \
            --stacktrace --info

          # Check if APK was built
          APK_PATH="app/build/outputs/apk/release/app-release-unsigned.apk"
          if [ -f "$APK_PATH" ]; then
            echo "✓ APK built successfully: $APK_PATH"

            # Copy APK to target directory for artifact upload
            mkdir -p ../../../target/android/apk
            cp "$APK_PATH" ../../../target/android/apk/ziplock-unsigned.apk

            # Show APK info
            echo "APK info:"
            ls -lh "$APK_PATH"
          else
            echo "✗ APK build failed - checking alternative locations..."
            find app/build/outputs/apk -name "*.apk" 2>/dev/null || echo "No APK files found"

            # Still create the directory structure for consistency
            mkdir -p ../../../target/android/apk
          fi

      - name: Upload Android artifacts
        uses: actions/upload-artifact@v4
        with:
          name: android-libraries
          path: target/android/
          retention-days: 30

  # Package for Debian/Ubuntu
  package-windows:
    name: Create Windows Package
    runs-on: windows-latest
    needs: [test-and-build, security-audit]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-pc-windows-msvc

      - name: Build Windows application
        run: |
          cd apps/desktop
          cargo build --release --target x86_64-pc-windows-msvc

      - name: Create MSI Installer
        run: |
          Write-Host "=== WiX Installation and Debugging ===" -ForegroundColor Green

          # Install WiX toolset
          Write-Host "Installing WiX toolset..." -ForegroundColor Cyan
          dotnet tool install --global wix --version 4.0.4
          Write-Host "WiX installation exit code: $LASTEXITCODE" -ForegroundColor Yellow

          # Debug environment
          Write-Host "`n=== Environment Debugging ===" -ForegroundColor Green
          Write-Host "Current PATH:" -ForegroundColor Cyan
          Write-Host $env:PATH -ForegroundColor Gray
          Write-Host "`nUSERPROFILE: $env:USERPROFILE" -ForegroundColor Cyan
          Write-Host "Current working directory: $(Get-Location)" -ForegroundColor Cyan

          # Check if wix.exe exists
          $wixPath = "$env:USERPROFILE\.dotnet\tools\wix.exe"
          Write-Host "`nChecking WiX executable at: $wixPath" -ForegroundColor Cyan
          if (Test-Path $wixPath) {
              Write-Host "WiX executable found!" -ForegroundColor Green
              $wixInfo = Get-Item $wixPath
              Write-Host "Size: $($wixInfo.Length) bytes" -ForegroundColor Gray
              Write-Host "Last modified: $($wixInfo.LastWriteTime)" -ForegroundColor Gray
          } else {
              Write-Host "WiX executable NOT found!" -ForegroundColor Red
              Write-Host "Listing contents of .dotnet/tools directory:" -ForegroundColor Yellow
              if (Test-Path "$env:USERPROFILE\.dotnet\tools") {
                  Get-ChildItem "$env:USERPROFILE\.dotnet\tools" | ForEach-Object { Write-Host "  $($_.Name)" -ForegroundColor Gray }
              } else {
                  Write-Host ".dotnet/tools directory does not exist!" -ForegroundColor Red
              }
          }

          # Add to PATH for current session
          Write-Host "`n=== Updating PATH ===" -ForegroundColor Green
          $toolsPath = "$env:USERPROFILE\.dotnet\tools"
          $env:PATH += ";$toolsPath"
          Write-Host "Added to PATH: $toolsPath" -ForegroundColor Cyan

          # Test wix command availability
          Write-Host "`n=== Testing WiX Command ===" -ForegroundColor Green
          try {
              Write-Host "Testing 'wix' command..." -ForegroundColor Cyan
              $wixVersion = & wix --version 2>&1
              Write-Host "WiX version output: $wixVersion" -ForegroundColor Green
          } catch {
              Write-Host "Error running 'wix' command: $_" -ForegroundColor Red
              Write-Host "Trying full path..." -ForegroundColor Yellow
              try {
                  $wixVersionFull = & $wixPath --version 2>&1
                  Write-Host "WiX version (full path): $wixVersionFull" -ForegroundColor Green
              } catch {
                  Write-Host "Error with full path too: $_" -ForegroundColor Red
              }
          }

          # List available extensions before installation
          Write-Host "`n=== Available Extensions (Before) ===" -ForegroundColor Green
          try {
              $extensionsBefore = & $wixPath extension list 2>&1
              Write-Host "Extensions before installation:" -ForegroundColor Cyan
              Write-Host "$extensionsBefore" -ForegroundColor Gray
          } catch {
              Write-Host "Error listing extensions: $_" -ForegroundColor Red
          }

          # Install UI extension with debugging
          Write-Host "`n=== Installing UI Extension ===" -ForegroundColor Green

          # First, try to remove any existing damaged extension
          Write-Host "Attempting to remove any existing UI extension..." -ForegroundColor Cyan
          try {
              $removeResult = & $wixPath extension remove WixToolset.UI.wixext 2>&1
              Write-Host "Extension remove result: $removeResult" -ForegroundColor Gray
              Write-Host "Extension remove exit code: $LASTEXITCODE" -ForegroundColor Yellow
          } catch {
              Write-Host "Remove failed (this is OK if extension wasn't installed): $_" -ForegroundColor Yellow
          }

          # Try multiple installation approaches
          Write-Host "Installing UI extension (attempt 1)..." -ForegroundColor Cyan
          try {
              $extensionResult = & $wixPath extension add WixToolset.UI.wixext 2>&1
              Write-Host "Extension add result: $extensionResult" -ForegroundColor Gray
              Write-Host "Extension add exit code: $LASTEXITCODE" -ForegroundColor Yellow

              if ($LASTEXITCODE -ne 0) {
                  Write-Host "First attempt failed, trying with --global flag..." -ForegroundColor Yellow
                  $extensionResult2 = & $wixPath extension add WixToolset.UI.wixext --global 2>&1
                  Write-Host "Global extension add result: $extensionResult2" -ForegroundColor Gray
                  Write-Host "Global extension add exit code: $LASTEXITCODE" -ForegroundColor Yellow

                  if ($LASTEXITCODE -ne 0) {
                      Write-Host "Global attempt failed, trying specific version..." -ForegroundColor Yellow
                      $extensionResult3 = & $wixPath extension add WixToolset.UI.wixext/4.0.5 2>&1
                      Write-Host "Specific version add result: $extensionResult3" -ForegroundColor Gray
                      Write-Host "Specific version add exit code: $LASTEXITCODE" -ForegroundColor Yellow
                  }
              }
          } catch {
              Write-Host "Error adding extension: $_" -ForegroundColor Red
          }

          # List available extensions after installation
          Write-Host "`n=== Available Extensions (After) ===" -ForegroundColor Green
          $extensionWorking = $false
          try {
              $extensionsAfter = & $wixPath extension list 2>&1
              Write-Host "Extensions after installation:" -ForegroundColor Cyan
              Write-Host "$extensionsAfter" -ForegroundColor Gray

              # Check if extension is working (not damaged)
              if ($extensionsAfter -notmatch "damaged" -and $extensionsAfter -match "WixToolset\.UI\.wixext") {
                  $extensionWorking = $true
                  Write-Host "UI extension appears to be working!" -ForegroundColor Green
              } else {
                  Write-Host "UI extension still appears damaged or missing" -ForegroundColor Yellow
              }
          } catch {
              Write-Host "Error listing extensions after: $_" -ForegroundColor Red
          }

          # Check for extension files
          Write-Host "`n=== Checking Extension Files ===" -ForegroundColor Green
          $extensionPaths = @(
              "$env:USERPROFILE\.wix\extensions",
              "$env:LOCALAPPDATA\wix\extensions",
              "$env:PROGRAMDATA\wix\extensions"
          )
          foreach ($extPath in $extensionPaths) {
              Write-Host "Checking: $extPath" -ForegroundColor Cyan
              if (Test-Path $extPath) {
                  Write-Host "Directory exists, contents:" -ForegroundColor Green
                  Get-ChildItem $extPath -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" -ForegroundColor Gray }
              } else {
                  Write-Host "Directory does not exist" -ForegroundColor Yellow
              }
          }

          $VERSION = "${{ needs.test-and-build.outputs.version }}"

          # Create staging directory
          Write-Host "`n=== Creating Package Structure ===" -ForegroundColor Green
          New-Item -ItemType Directory -Path "target/windows-package" -Force

          # Copy binary
          Copy-Item "target/x86_64-pc-windows-msvc/release/ziplock.exe" "target/windows-package/"

          # Download VC++ Redistributable
          Write-Host "Downloading VC++ Redistributable..." -ForegroundColor Cyan
          $vcRedistUrl = "https://aka.ms/vs/17/release/vc_redist.x64.exe"
          $vcRedistPath = "target/windows-package/vc_redist.x64.exe"
          try {
              Invoke-WebRequest -Uri $vcRedistUrl -OutFile $vcRedistPath -UseBasicParsing
              Write-Host "VC++ Redistributable downloaded: $(Get-Item $vcRedistPath | Select-Object -ExpandProperty Length) bytes" -ForegroundColor Green
          } catch {
              Write-Warning "Failed to download VC++ Redistributable: $_"
              # Create a dummy file so the build doesn't fail
              Set-Content -Path $vcRedistPath -Value "Dummy VC++ Redistributable file"
          }

          # Copy resources
          if (Test-Path "packaging/windows/resources") {
              Copy-Item "packaging/windows/resources/*" "target/windows-package/" -Recurse -Force
          }

          # Create application icon from executable
          Write-Host "Setting up application icon..." -ForegroundColor Cyan
          # The MSI will use the executable itself as the icon source

          # Verify staging directory
          Write-Host "Staging directory contents:" -ForegroundColor Cyan
          Get-ChildItem "target/windows-package" | ForEach-Object { Write-Host "  $($_.Name) ($($_.Length) bytes)" -ForegroundColor Gray }

          # Build MSI using WiX
          Write-Host "`n=== Building MSI ===" -ForegroundColor Green
          cd packaging/windows/installer
          Write-Host "Current directory: $(Get-Location)" -ForegroundColor Cyan
          Write-Host "WXS file exists: $(Test-Path 'ziplock.wxs')" -ForegroundColor Cyan

          # Try building with UI extension first
          if ($extensionWorking) {
              $buildCommand = "build ziplock.wxs -ext WixToolset.UI.wixext -define SourceDir=../../../target/windows-package -define Version=$VERSION -out ../../../target/ZipLock-$VERSION-x64.msi"
              Write-Host "Build command (with UI): wix $buildCommand" -ForegroundColor Cyan

              try {
                  & $wixPath $buildCommand.Split(' ')
                  Write-Host "Build exit code: $LASTEXITCODE" -ForegroundColor Yellow
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "MSI built successfully with UI extension!" -ForegroundColor Green
                  } else {
                      Write-Host "Build failed with UI extension, trying fallback..." -ForegroundColor Yellow
                      $extensionWorking = $false
                  }
              } catch {
                  Write-Host "Build error with UI extension: $_" -ForegroundColor Red
                  Write-Host "Trying fallback without UI extension..." -ForegroundColor Yellow
                  $extensionWorking = $false
              }
          }

          # Fallback: try building without UI extension
          if (-not $extensionWorking) {
              Write-Host "`n=== Fallback: Building without UI Extension ===" -ForegroundColor Yellow

              # Create a minimal WXS file without problematic elements
              $fallbackContent = @(
                '<?xml version="1.0" encoding="UTF-8"?>',
                '<Wix xmlns="http://wixtoolset.org/schemas/v4/wxs">',
                '  <Package Name="ZipLock Password Manager"',
                '           Language="1033"',
                "           Version=`"$VERSION`"",
                '           Manufacturer="ZipLock Project"',
                '           UpgradeCode="12345678-1234-1234-1234-123456789012"',
                '           InstallerVersion="500"',
                '           Compressed="yes"',
                '           Scope="perMachine">',
                '',
                '    <!-- Package description -->',
                '    <SummaryInformation Description="ZipLock Password Manager - Secure password management using encrypted 7z archives" />',
                '',
                '    <!-- Allow upgrades and prevent downgrades -->',
                '    <MajorUpgrade DowngradeErrorMessage="A newer version of [ProductName] is already installed." />',
                '',
                '    <!-- Embed the CAB file in the MSI -->',
                '    <Media Id="1" Cabinet="media1.cab" EmbedCab="yes" />',
                '',
                '    <!-- Feature definitions -->',
                '    <Feature Id="ProductFeature" Title="ZipLock Password Manager" Level="1">',
                '      <ComponentGroupRef Id="ProductComponents" />',
                '      <ComponentRef Id="ApplicationShortcut" />',
                '      <ComponentRef Id="DesktopShortcut" />',
                '    </Feature>',
                '',
                '    <!-- Installation directory structure -->',
                '    <StandardDirectory Id="ProgramFiles64Folder">',
                '      <Directory Id="INSTALLFOLDER" Name="ZipLock">',
                '        <Directory Id="BINDIR" Name="bin" />',
                '      </Directory>',
                '    </StandardDirectory>',
                '',
                '    <!-- Start Menu -->',
                '    <StandardDirectory Id="ProgramMenuFolder">',
                '      <Directory Id="ApplicationProgramsFolder" Name="ZipLock" />',
                '    </StandardDirectory>',
                '',
                '    <!-- Desktop -->',
                '    <StandardDirectory Id="DesktopFolder" />',
                '',
                '    <!-- Components -->',
                '    <ComponentGroup Id="ProductComponents" Directory="BINDIR">',
                '      <!-- Main executable -->',
                '      <Component Id="ZipLockExecutable">',
                '        <File Id="ZipLockExe"',
                '              Source="$$(var.SourceDir)\ziplock.exe"',
                '              Checksum="yes" />',
                '      </Component>',
                '    </ComponentGroup>',
                '',
                '    <!-- Application shortcuts -->',
                '    <Component Id="ApplicationShortcut" Directory="ApplicationProgramsFolder">',
                '      <Shortcut Id="ApplicationStartMenuShortcut"',
                '                Name="ZipLock Password Manager"',
                '                Target="[#ZipLockExe]"',
                '                WorkingDirectory="BINDIR"',
                '                Icon="ZipLockIcon.exe"',
                '                Description="Secure password management using encrypted archives" />',
                '      <RemoveFolder Id="CleanUpShortCut" Directory="ApplicationProgramsFolder" On="uninstall" />',
                '      <RegistryValue Root="HKCU" Key="Software\ZipLock" Name="installed" Type="integer" Value="1" />',
                '    </Component>',
                '',
                '    <!-- Desktop shortcut (optional) -->',
                '    <Component Id="DesktopShortcut" Directory="DesktopFolder">',
                '      <Shortcut Id="DesktopApplicationShortcut"',
                '                Name="ZipLock Password Manager"',
                '                Target="[#ZipLockExe]"',
                '                WorkingDirectory="BINDIR"',
                '                Icon="ZipLockIcon.exe"',
                '                Description="Secure password management using encrypted archives" />',
                '      <RegistryValue Root="HKCU" Key="Software\ZipLock" Name="desktop_shortcut" Type="integer" Value="1" />',
                '    </Component>',
                '',
                '    <!-- Icon definition -->',
                '    <Icon Id="ZipLockIcon.exe" SourceFile="$$(var.SourceDir)\ziplock.exe" />',
                '',
                '    <!-- Properties for Add/Remove Programs -->',
                '    <Property Id="ARPPRODUCTICON" Value="ZipLockIcon.exe" />',
                '    <Property Id="ARPHELPLINK" Value="https://github.com/ejangi/ziplock" />',
                '    <Property Id="ARPURLINFOABOUT" Value="https://github.com/ejangi/ziplock" />',
                '    <Property Id="ARPNOREPAIR" Value="1" />',
                '    <Property Id="ARPNOMODIFY" Value="1" />',
                '',
                '  </Package>',
                '</Wix>'
              )

              Set-Content "ziplock-fallback.wxs" ($fallbackContent -join "`n") -Encoding UTF8
              Write-Host "Created minimal fallback WXS file" -ForegroundColor Cyan

              $fallbackCommand = "build ziplock-fallback.wxs -define SourceDir=../../../target/windows-package -define Version=$VERSION -out ../../../target/ZipLock-$VERSION-x64.msi"
              Write-Host "Fallback build command: wix $fallbackCommand" -ForegroundColor Cyan

              try {
                  & $wixPath $fallbackCommand.Split(' ')
                  Write-Host "Fallback build exit code: $LASTEXITCODE" -ForegroundColor Yellow
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "MSI built successfully without UI extension!" -ForegroundColor Green
                  } else {
                      Write-Host "Fallback build also failed!" -ForegroundColor Red
                      throw "Both UI and fallback builds failed"
                  }
              } catch {
                  Write-Host "Fallback build error: $_" -ForegroundColor Red
                  throw
              }
          }

          # Verify and log created artifacts
          Write-Host "`n=== Build Artifacts ===" -ForegroundColor Green
          $targetDir = "../../../target"
          Write-Host "Checking target directory: $targetDir" -ForegroundColor Cyan

          if (Test-Path $targetDir) {
              $msiFiles = Get-ChildItem $targetDir -Filter "*.msi" | Sort-Object LastWriteTime -Descending
              if ($msiFiles.Count -gt 0) {
                  Write-Host "Found $($msiFiles.Count) MSI file(s):" -ForegroundColor Green
                  foreach ($msi in $msiFiles) {
                      Write-Host "  - $($msi.Name)" -ForegroundColor Cyan
                      Write-Host "    Size: $([math]::Round($msi.Length / 1MB, 2)) MB" -ForegroundColor Gray
                      Write-Host "    Created: $($msi.CreationTime)" -ForegroundColor Gray
                      Write-Host "    Modified: $($msi.LastWriteTime)" -ForegroundColor Gray
                      Write-Host "    Full path: $($msi.FullName)" -ForegroundColor Gray
                  }
              } else {
                  Write-Host "No MSI files found in target directory!" -ForegroundColor Red
              }

              # List all files in target directory for debugging
              Write-Host "`nAll files in target directory:" -ForegroundColor Yellow
              Get-ChildItem $targetDir -Recurse | ForEach-Object {
                  if (-not $_.PSIsContainer) {
                      Write-Host "  $($_.FullName.Replace($PWD.Path, '.'))" -ForegroundColor Gray
                  }
              }

              # Test MSI properties if possible
              Write-Host "`nTesting MSI properties..." -ForegroundColor Yellow
              $newestMsi = $msiFiles | Select-Object -First 1
              if ($newestMsi) {
                  try {
                      # Basic file validation
                      Write-Host "MSI file appears to be valid (size > 1MB)" -ForegroundColor Green
                  } catch {
                      Write-Warning "Could not validate MSI properties: $_"
                  }
              }
          } else {
              Write-Host "Target directory not found: $targetDir" -ForegroundColor Red
          }

      - name: Upload Windows package
        uses: actions/upload-artifact@v4
        with:
          name: windows-package
          path: target/ZipLock-*.msi
          retention-days: 30

  package-macos:
    name: Create macOS Package
    runs-on: macos-latest
    needs: [test-and-build, security-audit]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-apple-darwin

      - name: Build macOS application
        run: |
          cd apps/desktop
          cargo build --release --target x86_64-apple-darwin

      - name: Create App Bundle
        run: |
          VERSION="${{ needs.test-and-build.outputs.version }}"

          # Run app bundle creation script
          chmod +x packaging/macos/scripts/create-app-bundle.sh
          ./packaging/macos/scripts/create-app-bundle.sh --config release --target x86_64-apple-darwin --output target/macos-package

      - name: Create DMG
        run: |
          VERSION="${{ needs.test-and-build.outputs.version }}"

          # Create DMG
          mkdir -p target/dmg
          cp -R target/macos-package/ZipLock.app target/dmg/

          # Create a simple DMG (can be enhanced later with custom layout)
          hdiutil create -volname "ZipLock $VERSION" -srcfolder target/dmg -ov -format UDZO target/ZipLock-$VERSION.dmg

      - name: Upload macOS package
        uses: actions/upload-artifact@v4
        with:
          name: macos-package
          path: |
            target/ZipLock-*.dmg
            target/macos-package/ZipLock.app
          retention-days: 30

  package-debian:
    name: Create Debian Package
    runs-on: ubuntu-22.04
    needs: [test-and-build, security-audit]
    container: ghcr.io/ejangi/ziplock/ubuntu-builder:latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Linux binaries
        uses: actions/download-artifact@v4
        with:
          name: linux-binaries
          path: target/artifacts/linux/

      - name: Create Debian package
        run: |
          # Create package structure
          VERSION="${{ needs.test-and-build.outputs.version }}"
          PKG_DIR="target/debian-package"
          INSTALL_DIR="$PKG_DIR/usr"

          mkdir -p "$INSTALL_DIR/bin"
          mkdir -p "$INSTALL_DIR/share/applications"
          mkdir -p "$INSTALL_DIR/share/icons/hicolor/scalable/apps"
          mkdir -p "$INSTALL_DIR/share/metainfo"
          mkdir -p "$PKG_DIR/DEBIAN"

          # Debug: Check artifact structure
          echo "=== Debugging artifact structure ==="
          echo "Contents of target/artifacts/linux/:"
          ls -la target/artifacts/linux/ || echo "Directory not found"
          echo "Contents of target/artifacts/linux/binaries/:"
          ls -la target/artifacts/linux/binaries/ || echo "Directory not found"
          echo "Finding all files in target/artifacts/:"
          find target/artifacts/ -type f 2>/dev/null || echo "No files found"

          # Copy binaries and make them executable
          if [ -d "target/artifacts/linux/binaries" ]; then
            echo "Copying from binaries directory..."
            cp target/artifacts/linux/binaries/* "$INSTALL_DIR/bin/"
            chmod +x "$INSTALL_DIR/bin/"*
          elif [ -d "target/artifacts/linux" ]; then
            echo "Copying from linux directory..."
            find target/artifacts/linux -type f -exec cp {} "$INSTALL_DIR/bin/" \;
            chmod +x "$INSTALL_DIR/bin/"*
          else
            echo "Error: No artifact directories found"
            exit 1
          fi

          # Verify binaries were copied
          echo "Binaries copied to $INSTALL_DIR/bin/:"
          ls -la "$INSTALL_DIR/bin/"

          # Copy desktop integration files if they exist
          if [ -f "packaging/linux/ziplock.desktop" ]; then
            cp packaging/linux/ziplock.desktop "$INSTALL_DIR/share/applications/"
          fi

          if [ -f "packaging/linux/ziplock.svg" ]; then
            cp packaging/linux/ziplock.svg "$INSTALL_DIR/share/icons/hicolor/scalable/apps/"
          fi

          if [ -f "packaging/linux/ziplock.metainfo.xml" ]; then
            cp packaging/linux/ziplock.metainfo.xml "$INSTALL_DIR/share/metainfo/"
          fi

          # Create control file
          cat > "$PKG_DIR/DEBIAN/control" << EOF
          Package: ziplock
          Version: $VERSION
          Section: utils
          Priority: optional
          Architecture: amd64
          Depends: libgtk-4-1, libadwaita-1-0
          Maintainer: ZipLock Team <contact@ziplock.dev>
          Description: Secure archive manager with modern encryption
           ZipLock is a secure archive manager that provides modern encryption
           for your files and directories. It features a clean GTK4 interface
           and strong cryptographic protection for your data.
          EOF

          # Create postinst script for desktop integration
          cat > "$PKG_DIR/DEBIAN/postinst" << 'EOF'
          #!/bin/bash
          set -e
          if [ "$1" = "configure" ]; then
              # Update desktop database
              if command -v update-desktop-database >/dev/null 2>&1; then
                  update-desktop-database -q /usr/share/applications || true
              fi

              # Update icon cache
              if command -v gtk-update-icon-cache >/dev/null 2>&1; then
                  gtk-update-icon-cache -q /usr/share/icons/hicolor || true
              fi
          fi
          EOF

          chmod 755 "$PKG_DIR/DEBIAN/postinst"

          # Build package
          dpkg-deb --root-owner-group --build "$PKG_DIR" "target/ziplock_${VERSION}_amd64.deb"

      - name: Test package installation
        run: |
          # Install virtual display and X11 libraries for GUI testing
          apt-get update
          apt-get install -y xvfb libxkbcommon-x11-0

          # Install the package
          dpkg -i target/ziplock_*.deb || true
          apt-get install -f -y

          # Verify installation
          which ziplock

          # Test with virtual display and timeout (GUI apps may hang)
          timeout 10s xvfb-run -a ziplock --version || echo "GUI test completed (timeout or exit)"

      - name: Upload Debian package
        uses: actions/upload-artifact@v4
        with:
          name: debian-package
          path: target/ziplock_*_amd64.deb
          retention-days: 30

  # Package for Arch Linux
  package-arch:
    name: Create Arch Package
    runs-on: ubuntu-22.04
    needs: [test-and-build, security-audit]
    container:
      image: ghcr.io/ejangi/ziplock/arch-builder:latest
      options: --user root

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Linux binaries
        uses: actions/download-artifact@v4
        with:
          name: linux-binaries
          path: target/artifacts/linux/

      - name: Create Arch package
        run: |
          VERSION="${{ needs.test-and-build.outputs.version }}"

          # Create package directory with proper permissions
          mkdir -p /tmp/arch-package
          cd /tmp/arch-package

          # Create source directory structure
          mkdir -p ziplock-src

          # Copy source files (avoiding recursive copy)
          rsync -av --exclude='target/' --exclude='.git/' "$GITHUB_WORKSPACE/" ziplock-src/

          # Create PKGBUILD
          cat > PKGBUILD << EOF
          # Maintainer: ZipLock Team <contact@ziplock.dev>
          pkgname=ziplock
          pkgver=$VERSION
          pkgrel=1
          pkgdesc="Secure archive manager with modern encryption"
          arch=('x86_64')
          url="https://github.com/ejangi/ziplock"
          license=('GPL3')
          depends=('gtk4' 'libadwaita')
          makedepends=('rust' 'cargo' 'pkg-config')
          source=("\$pkgname-\$pkgver.tar.gz::https://github.com/ejangi/ziplock/archive/v\$pkgver.tar.gz")
          sha256sums=('SKIP')

          build() {
              cd "\$pkgname-\$pkgver"
              export CARGO_TARGET_DIR=target
              cargo build --release --locked
          }

          check() {
              cd "\$pkgname-\$pkgver"
              cargo test --release --locked
          }

          package() {
              cd "\$pkgname-\$pkgver"

              # Install binaries (using pre-built artifacts)
              install -Dm755 ../../../target/artifacts/linux/binaries/ziplock "\$pkgdir/usr/bin/ziplock"

              # Install desktop integration files if they exist
              if [ -f packaging/linux/ziplock.desktop ]; then
                  install -Dm644 packaging/linux/ziplock.desktop "\$pkgdir/usr/share/applications/ziplock.desktop"
              fi

              if [ -f packaging/linux/ziplock.svg ]; then
                  install -Dm644 packaging/linux/ziplock.svg "\$pkgdir/usr/share/icons/hicolor/scalable/apps/ziplock.svg"
              fi

              if [ -f packaging/linux/ziplock.metainfo.xml ]; then
                  install -Dm644 packaging/linux/ziplock.metainfo.xml "\$pkgdir/usr/share/metainfo/ziplock.metainfo.xml"
              fi

              # Install documentation
              install -Dm644 README.md "\$pkgdir/usr/share/doc/ziplock/README.md"
              install -Dm644 CHANGELOG.md "\$pkgdir/usr/share/doc/ziplock/CHANGELOG.md"
          }
          EOF

          # Create install script for AUR
          cat > ziplock.install << 'EOF'
          post_install() {
              update-desktop-database -q
              gtk-update-icon-cache -q /usr/share/icons/hicolor
          }

          post_upgrade() {
              post_install
          }

          post_remove() {
              update-desktop-database -q
              gtk-update-icon-cache -q /usr/share/icons/hicolor
          }
          EOF

          # Create source archive for AUR
          tar -czf "ziplock-${VERSION}.tar.gz" ziplock-src/

          # Change ownership to builder user and build
          chown -R builder:builder .

          # Generate .SRCINFO for AUR
          sudo -u builder makepkg --printsrcinfo > .SRCINFO

          # Copy results back to workspace
          cp PKGBUILD .SRCINFO ziplock.install ziplock-*.tar.gz "$GITHUB_WORKSPACE/target/arch-package/" || true
          mkdir -p "$GITHUB_WORKSPACE/target/arch-package"
          cp PKGBUILD .SRCINFO ziplock.install ziplock-*.tar.gz "$GITHUB_WORKSPACE/target/arch-package/"

      - name: Upload Arch package
        uses: actions/upload-artifact@v4
        with:
          name: arch-package
          path: target/arch-package/
          retention-days: 30

  # Performance benchmarks (only on main branch)
  benchmark:
    name: Performance Benchmarks
    runs-on: ubuntu-22.04
    needs: [test-and-build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Linux binaries
        uses: actions/download-artifact@v4
        with:
          name: linux-binaries
          path: target/artifacts/linux/

      - name: Run benchmarks
        run: |
          # Make binaries executable
          chmod +x target/artifacts/linux/binaries/*

          # Install virtual display for GUI testing
          sudo apt-get update
          sudo apt-get install -y xvfb

          # Run basic performance tests
          echo "# ZipLock Performance Benchmarks" > benchmark-results.md
          echo "Generated: $(date -u)" >> benchmark-results.md
          echo "Commit: ${{ github.sha }}" >> benchmark-results.md
          echo "" >> benchmark-results.md

          # Test basic functionality with virtual display for GUI app
          echo "## Version Information" >> benchmark-results.md
          echo '```' >> benchmark-results.md

          # GUI version with virtual display
          xvfb-run -a ./target/artifacts/linux/binaries/ziplock --version >> benchmark-results.md 2>&1 || echo "ziplock version failed" >> benchmark-results.md

          echo '```' >> benchmark-results.md
          echo "" >> benchmark-results.md

          # Basic functionality test
          echo "## Basic Functionality Test" >> benchmark-results.md
          echo '```' >> benchmark-results.md
          xvfb-run -a ./target/artifacts/linux/binaries/ziplock --help | head -10 >> benchmark-results.md 2>&1 || echo "Help command failed" >> benchmark-results.md
          echo '```' >> benchmark-results.md

      - name: Upload benchmark results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: benchmark-results.md
          retention-days: 30

  # Create unified release (only on tags)
  release:
    name: Create Release
    runs-on: ubuntu-22.04
    needs:
      [
        test-and-build,
        build-android,
        package-debian,
        package-arch,
        package-windows,
        package-macos,
        security-audit,
      ]
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Create unified release structure
        run: |
          VERSION="${{ needs.test-and-build.outputs.version }}"
          RELEASE_DIR="unified-release"

          # Create release directory structure
          mkdir -p "$RELEASE_DIR"/{linux/{binaries,packages},windows/{binaries,packages},macos/{binaries,packages},android/{libraries,headers},docs}

          # Copy Linux binaries
          if [ -d "artifacts/linux-binaries" ]; then
            cp -r artifacts/linux-binaries/* "$RELEASE_DIR/linux/"
          fi

          # Copy Linux packages
          if [ -d "artifacts/debian-package" ]; then
            cp artifacts/debian-package/*.deb "$RELEASE_DIR/linux/packages/" 2>/dev/null || true
          fi

          if [ -d "artifacts/arch-package" ]; then
            mkdir -p "$RELEASE_DIR/linux/packages/arch"
            cp artifacts/arch-package/* "$RELEASE_DIR/linux/packages/arch/" 2>/dev/null || true
          fi

          # Copy Windows packages
          if [ -d "artifacts/windows-package" ]; then
            mkdir -p "$RELEASE_DIR/windows/packages"
            cp artifacts/windows-package/*.msi "$RELEASE_DIR/windows/packages/" 2>/dev/null || true
            # Also copy binary for manual installation
            mkdir -p "$RELEASE_DIR/windows/binaries"
            cp artifacts/windows-package/ziplock.exe "$RELEASE_DIR/windows/binaries/" 2>/dev/null || true
          fi

          # Copy macOS packages
          if [ -d "artifacts/macos-package" ]; then
            mkdir -p "$RELEASE_DIR/macos/packages"
            cp artifacts/macos-package/*.dmg "$RELEASE_DIR/macos/packages/" 2>/dev/null || true
            # Copy app bundle
            if [ -d "artifacts/macos-package/ZipLock.app" ]; then
              cp -r artifacts/macos-package/ZipLock.app "$RELEASE_DIR/macos/packages/"
            fi
          fi

          # Copy Android libraries and APK
          if [ -d "artifacts/android-libraries" ]; then
            cp -r artifacts/android-libraries/* "$RELEASE_DIR/android/libraries/"

            # Copy headers if they exist
            if [ -f "artifacts/android-libraries/ziplock.h" ]; then
              cp artifacts/android-libraries/ziplock.h "$RELEASE_DIR/android/headers/"
            fi

            # Copy APK if it exists
            if [ -f "artifacts/android-libraries/apk/ziplock-unsigned.apk" ]; then
              mkdir -p "$RELEASE_DIR/android/apk"
              cp artifacts/android-libraries/apk/ziplock-unsigned.apk "$RELEASE_DIR/android/apk/"
              echo "✓ Android APK included in release"
            fi
          fi

          # Copy documentation
          cp README.md "$RELEASE_DIR/docs/"
          cp CHANGELOG.md "$RELEASE_DIR/docs/" 2>/dev/null || true
          cp -r docs/ "$RELEASE_DIR/docs/technical/" 2>/dev/null || true

          # Create release info
          cat > "$RELEASE_DIR/release-info.json" << EOF
          {
            "version": "$VERSION",
            "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "platforms": {
              "linux": {
                "architectures": ["x86_64"],
                "formats": ["deb", "arch"]
              },
              "windows": {
                "architectures": ["x86_64"],
                "formats": ["msi", "exe"]
              },
              "macos": {
                "architectures": ["x86_64"],
                "formats": ["dmg", "app"]
              },
              "android": {
                "architectures": ["arm64-v8a", "armeabi-v7a"],
                "api_level": 21,
                "apk_included": true
              }
            }
          }
          EOF

          # Create README for the release
          cat > "$RELEASE_DIR/README.md" << EOF
          # ZipLock v$VERSION - Unified Release

          This is a unified release containing both Linux and Android builds of ZipLock.

          ## Contents

          ### Linux (x86_64)
          - \`linux/binaries/\` - Compiled binaries for Linux
          - \`linux/packages/ziplock_${VERSION}_amd64.deb\` - Debian/Ubuntu package
          - \`linux/packages/arch/\` - Arch Linux package files (PKGBUILD, etc.)

          ### Android
          - \`android/libraries/\` - Native libraries for Android
            - \`arm64-v8a/\` - ARM64 libraries (modern devices)
            - \`armeabi-v7a/\` - ARMv7 libraries (older devices)
          - \`android/headers/\` - C header files for integration
          - \`android/apk/\` - Pre-built Android APK (unsigned)

          ### Documentation
          - \`docs/\` - Complete project documentation

          ## Installation

          ### Linux
          - **Debian/Ubuntu**: \`sudo dpkg -i linux/packages/ziplock_${VERSION}_amd64.deb\`
          - **Arch Linux**: Use the PKGBUILD in \`linux/packages/arch/\`
          - **Manual**: Copy binaries from \`linux/binaries/\` to your PATH

          ### Windows
          - **MSI Installer**: Download and run \`windows/packages/ZipLock-${VERSION}-x64.msi\`
          - **Manual**: Extract and run \`ziplock.exe\` from \`windows/binaries/\`

          ### macOS
          - **DMG Package**: Download and install \`macos/packages/ZipLock-${VERSION}.dmg\`
          - **App Bundle**: Extract \`ZipLock.app\` from \`macos/packages/\` to Applications folder

          ### Android
          - **APK Installation**: Install the unsigned APK with \`adb install android/apk/ziplock-unsigned.apk\`
          - **Development**: See the technical documentation in \`docs/technical/android.md\` for integration instructions.

          ## Build Information
          - **Version**: $VERSION
          - **Build Date**: $(date -u)
          - **Commit**: ${{ github.sha }}
          EOF

          # Create compressed archive
          tar -czf "ziplock-v${VERSION}-unified-release.tar.gz" "$RELEASE_DIR"

      - name: Extract changelog for version
        id: changelog
        run: |
          VERSION="${{ needs.test-and-build.outputs.version }}"
          if [ -f CHANGELOG.md ]; then
            # Extract changelog section for this version
            sed -n "/## \[${VERSION}\]/,/## \[/p" CHANGELOG.md | sed '$d' > version_changelog.md
            echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
            cat version_changelog.md >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "CHANGELOG=No changelog available for this release." >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: "ZipLock v${{ needs.test-and-build.outputs.version }}"
          body: |
            # ZipLock v${{ needs.test-and-build.outputs.version }} - Unified Release

            This release includes builds for both Linux and Android platforms in a single unified package.

            ## 📦 Release Contents

            ### Linux Builds
            - **Debian/Ubuntu Package**: Ready-to-install .deb package for x86_64
            - **Arch Linux Package**: PKGBUILD and source files for Arch Linux/AUR
            - **Standalone Binaries**: Direct executables for manual installation

            ### Android Builds
            - **Android APK**: Pre-built unsigned APK ready for installation or signing
            - **Native Libraries**: ARM64 and ARMv7 shared libraries (.so files) for Android integration
            - **Headers**: C header files for FFI integration
            - **Documentation**: Complete integration guide

            ## 🚀 Quick Start

            **Linux (Debian/Ubuntu):**
            ```bash
            wget https://github.com/ejangi/ziplock/releases/download/v${{ needs.test-and-build.outputs.version }}/ziplock_${{ needs.test-and-build.outputs.version }}_amd64.deb
            sudo dpkg -i ziplock_${{ needs.test-and-build.outputs.version }}_amd64.deb
            ```

            **Linux (Arch):**
            Download the arch package files and use makepkg, or install from AUR.

            **Windows:**
            ```bash
            # Download and install MSI package
            wget https://github.com/ejangi/ziplock/releases/download/v${{ needs.test-and-build.outputs.version }}/ZipLock-${{ needs.test-and-build.outputs.version }}-x64.msi
            # Double-click to install, or use msiexec /i ZipLock-${{ needs.test-and-build.outputs.version }}-x64.msi
            ```

            **macOS:**
            ```bash
            # Download and install DMG package
            wget https://github.com/ejangi/ziplock/releases/download/v${{ needs.test-and-build.outputs.version }}/ZipLock-${{ needs.test-and-build.outputs.version }}.dmg
            # Open DMG and drag ZipLock.app to Applications folder
            ```

            **Android:**
            ```bash
            # Install APK directly (requires ADB and connected device)
            wget https://github.com/ejangi/ziplock/releases/download/v${{ needs.test-and-build.outputs.version }}/ziplock-unsigned.apk
            adb install ziplock-unsigned.apk

            # Or download full release for development
            wget https://github.com/ejangi/ziplock/releases/download/v${{ needs.test-and-build.outputs.version }}/ziplock-v${{ needs.test-and-build.outputs.version }}-unified-release.tar.gz
            ```

            ## 📋 Changelog

            ${{ steps.changelog.outputs.CHANGELOG }}

            ## 🔧 Technical Details

            - **Build Date**: $(date -u)
            - **Commit**: ${{ github.sha }}
            - **Platforms**: Linux (x86_64), Windows (x64), macOS (x86_64), Android (ARM64/ARMv7)
            - **Dependencies**: GTK4, libadwaita (Linux), Visual C++ Redistributable (Windows), macOS 10.15+ (macOS), API 21+ (Android)
          draft: false
          prerelease: ${{ contains(needs.test-and-build.outputs.version, '-') }}
          files: |
            ziplock-v${{ needs.test-and-build.outputs.version }}-unified-release.tar.gz
            artifacts/debian-package/*.deb
            artifacts/arch-package/*
            artifacts/windows-package/*.msi
            artifacts/macos-package/*.dmg
            artifacts/android-libraries/apk/ziplock-unsigned.apk
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
