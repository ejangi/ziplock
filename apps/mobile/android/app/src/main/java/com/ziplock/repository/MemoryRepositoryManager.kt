package com.ziplock.repository

import android.content.Context
import android.util.Log
import com.ziplock.archive.ArchiveManager
import com.ziplock.ffi.ZipLockMemoryRepository
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString
import java.io.File
import java.io.FileWriter
import java.nio.file.Files
import java.util.*

/**
 * Enhanced repository manager that uses the centralized memory repository
 * for all file structure and content management. This implementation follows
 * the new architecture where:
 *
 * 1. Kotlin handles only archive open/close operations
 * 2. The shared Rust library manages ALL file structure and content
 * 3. File operations are generated by the memory repository and executed by Kotlin
 *
 * This ensures consistent file structure across all platforms.
 */
class MemoryRepositoryManager(private val context: Context) {

    companion object {
        private const val TAG = "MemoryRepositoryManager"
        private const val TEMP_EXTRACT_PREFIX = "ziplock_memory_extract_"
    }

    private val archiveManager = ArchiveManager(context)
    private val memoryRepository = ZipLockMemoryRepository()
    private val json = Json {
        prettyPrint = true
        ignoreUnknownKeys = true
    }



    private var currentArchivePath: String? = null
    private var currentPassword: String? = null
    private var currentExtractedPath: String? = null
    private var isOpen = false

    /**
     * Initialize the memory repository manager
     */
    suspend fun initialize(): ZipLockMemoryRepository.RepositoryResult<Boolean> = withContext(Dispatchers.IO) {
        try {
            val initResult = memoryRepository.initialize()
            if (!initResult.success) {
                return@withContext ZipLockMemoryRepository.RepositoryResult(
                    success = false,
                    errorMessage = initResult.errorMessage ?: "Failed to initialize memory repository"
                )
            }

            Log.i(TAG, "Memory repository manager initialized successfully")
            Log.i(TAG, "Library version: ${memoryRepository.getVersion()}")

            ZipLockMemoryRepository.RepositoryResult(success = true, data = true)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize memory repository manager", e)
            ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "Failed to initialize: ${e.message}"
            )
        }
    }

    /**
     * Open an existing repository from archive
     */
    suspend fun openRepository(
        archivePath: String,
        password: String
    ): ZipLockMemoryRepository.RepositoryResult<Boolean> = withContext(Dispatchers.IO) {
        try {
            if (isOpen) {
                closeRepository()
            }

            // Step 1: Extract archive using Kotlin (platform-specific file operations)
            val tempDir = Files.createTempDirectory(TEMP_EXTRACT_PREFIX).toFile()

            val extractResult = archiveManager.openArchive(archivePath, password, tempDir)
            if (!extractResult.success) {
                tempDir.deleteRecursively()
                return@withContext ZipLockMemoryRepository.RepositoryResult(
                    success = false,
                    errorMessage = extractResult.errorMessage ?: "Failed to extract archive"
                )
            }

            // Step 2: Load extracted content into memory repository
            val extractedFiles = loadFilesFromDirectory(tempDir)
            val loadResult = memoryRepository.loadContent(extractedFiles)

            if (!loadResult.success) {
                tempDir.deleteRecursively()
                return@withContext ZipLockMemoryRepository.RepositoryResult(
                    success = false,
                    errorMessage = loadResult.errorMessage ?: "Failed to load repository content"
                )
            }

            // Step 3: Update state
            currentArchivePath = archivePath
            currentPassword = password
            currentExtractedPath = tempDir.absolutePath
            isOpen = true

            Log.i(TAG, "Repository opened successfully from: $archivePath")

            ZipLockMemoryRepository.RepositoryResult(success = true, data = true)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to open repository", e)
            ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "Failed to open repository: ${e.message}"
            )
        }
    }

    /**
     * Create a new repository
     */
    suspend fun createRepository(
        archivePath: String,
        password: String
    ): ZipLockMemoryRepository.RepositoryResult<Boolean> = withContext(Dispatchers.IO) {
        try {
            if (isOpen) {
                closeRepository()
            }

            // The memory repository is already initialized with empty state
            // Just set up the archive path and password for saving
            currentArchivePath = archivePath
            currentPassword = password
            isOpen = true

            Log.i(TAG, "New repository created for: $archivePath")

            ZipLockMemoryRepository.RepositoryResult(success = true, data = true)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to create repository", e)
            ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "Failed to create repository: ${e.message}"
            )
        }
    }

    /**
     * Save the repository to archive
     */
    suspend fun saveRepository(): ZipLockMemoryRepository.RepositoryResult<Boolean> = withContext(Dispatchers.IO) {
        try {
            if (!isOpen || currentArchivePath == null || currentPassword == null) {
                return@withContext ZipLockMemoryRepository.RepositoryResult(
                    success = false,
                    errorMessage = "No repository is currently open"
                )
            }

            // Step 1: Get file operations from memory repository
            val operationsResult = memoryRepository.getFileOperations()
            if (!operationsResult.success) {
                return@withContext ZipLockMemoryRepository.RepositoryResult(
                    success = false,
                    errorMessage = operationsResult.errorMessage ?: "Failed to get file operations"
                )
            }

            val fileOperations = operationsResult.data ?: emptyList()

            // Step 2: Create temporary directory and execute file operations
            val tempDir = Files.createTempDirectory(TEMP_EXTRACT_PREFIX).toFile()

            try {
                for (operation in fileOperations) {
                    executeFileOperation(tempDir, operation)
                }

                // Step 3: Create archive from temporary directory
                val createResult = archiveManager.createArchive(
                    currentArchivePath!!,
                    currentPassword!!,
                    tempDir
                )

                if (!createResult.success) {
                    return@withContext ZipLockMemoryRepository.RepositoryResult(
                        success = false,
                        errorMessage = createResult.errorMessage ?: "Failed to create archive"
                    )
                }

                Log.i(TAG, "Repository saved successfully to: ${currentArchivePath}")

                ZipLockMemoryRepository.RepositoryResult(success = true, data = true)
            } finally {
                // Clean up temporary directory
                tempDir.deleteRecursively()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to save repository", e)
            ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "Failed to save repository: ${e.message}"
            )
        }
    }

    /**
     * Close the current repository
     */
    suspend fun closeRepository(): ZipLockMemoryRepository.RepositoryResult<Boolean> = withContext(Dispatchers.IO) {
        try {
            if (currentExtractedPath != null) {
                File(currentExtractedPath!!).deleteRecursively()
            }

            currentArchivePath = null
            currentPassword = null
            currentExtractedPath = null
            isOpen = false

            Log.i(TAG, "Repository closed successfully")

            ZipLockMemoryRepository.RepositoryResult(success = true, data = true)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to close repository", e)
            ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "Failed to close repository: ${e.message}"
            )
        }
    }

    /**
     * Add a credential to the repository
     */
    suspend fun addCredential(
        credential: ZipLockMemoryRepository.SerializedCredential
    ): ZipLockMemoryRepository.RepositoryResult<String> = withContext(Dispatchers.IO) {
        if (!isOpen) {
            return@withContext ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "No repository is open"
            )
        }

        memoryRepository.addCredential(credential)
    }

    /**
     * Get a credential from the repository
     */
    suspend fun getCredential(
        credentialId: String
    ): ZipLockMemoryRepository.RepositoryResult<ZipLockMemoryRepository.SerializedCredential> = withContext(Dispatchers.IO) {
        if (!isOpen) {
            return@withContext ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "No repository is open"
            )
        }

        memoryRepository.getCredential(credentialId)
    }

    /**
     * Update a credential in the repository
     */
    suspend fun updateCredential(
        credential: ZipLockMemoryRepository.SerializedCredential
    ): ZipLockMemoryRepository.RepositoryResult<Boolean> = withContext(Dispatchers.IO) {
        if (!isOpen) {
            return@withContext ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "No repository is open"
            )
        }

        memoryRepository.updateCredential(credential)
    }

    /**
     * Delete a credential from the repository
     */
    suspend fun deleteCredential(credentialId: String): ZipLockMemoryRepository.RepositoryResult<Boolean> = withContext(Dispatchers.IO) {
        if (!isOpen) {
            return@withContext ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "No repository is open"
            )
        }

        memoryRepository.deleteCredential(credentialId)
    }

    /**
     * List all credentials in the repository
     */
    suspend fun listCredentials(): ZipLockMemoryRepository.RepositoryResult<List<ZipLockMemoryRepository.SerializedCredential>> = withContext(Dispatchers.IO) {
        if (!isOpen) {
            return@withContext ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "No repository is open"
            )
        }

        memoryRepository.listCredentials()
    }

    /**
     * Search credentials in the repository
     */
    suspend fun searchCredentials(
        query: String
    ): ZipLockMemoryRepository.RepositoryResult<List<ZipLockMemoryRepository.SerializedCredential>> = withContext(Dispatchers.IO) {
        if (!isOpen) {
            return@withContext ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "No repository is open"
            )
        }

        memoryRepository.searchCredentials(query)
    }

    /**
     * Get repository metadata
     */
    suspend fun getMetadata(): ZipLockMemoryRepository.RepositoryResult<ZipLockMemoryRepository.RepositoryMetadata> = withContext(Dispatchers.IO) {
        if (!isOpen) {
            return@withContext ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "No repository is open"
            )
        }

        memoryRepository.getMetadata()
    }

    /**
     * Get repository structure
     */
    suspend fun getStructure(): ZipLockMemoryRepository.RepositoryResult<ZipLockMemoryRepository.RepositoryStructure> = withContext(Dispatchers.IO) {
        if (!isOpen) {
            return@withContext ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "No repository is open"
            )
        }

        memoryRepository.getStructure()
    }

    /**
     * Check if repository is open
     */
    fun isRepositoryOpen(): Boolean = isOpen

    /**
     * Get current archive path
     */
    fun getCurrentArchivePath(): String? = currentArchivePath

    /**
     * Clean up resources
     */
    suspend fun cleanup(): ZipLockMemoryRepository.RepositoryResult<Boolean> = withContext(Dispatchers.IO) {
        try {
            closeRepository()
            memoryRepository.cleanup()
            ZipLockMemoryRepository.RepositoryResult(success = true, data = true)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to cleanup", e)
            ZipLockMemoryRepository.RepositoryResult(
                success = false,
                errorMessage = "Cleanup failed: ${e.message}"
            )
        }
    }

    /**
     * Private helper methods
     */

    private fun loadFilesFromDirectory(directory: File): Map<String, ByteArray> {
        val files = mutableMapOf<String, ByteArray>()

        fun loadRecursively(dir: File, basePath: String = "") {
            dir.listFiles()?.forEach { file ->
                val relativePath = if (basePath.isEmpty()) file.name else "$basePath/${file.name}"

                if (file.isFile) {
                    files[relativePath] = file.readBytes()
                } else if (file.isDirectory) {
                    loadRecursively(file, relativePath)
                }
            }
        }

        loadRecursively(directory)
        return files
    }

    private fun executeFileOperation(
        baseDir: File,
        operation: ZipLockMemoryRepository.FileOperation
    ) {
        val targetFile = File(baseDir, operation.path)

        when (operation.operation) {
            "create" -> {
                if (operation.isDirectory) {
                    targetFile.mkdirs()
                } else {
                    // Ensure parent directory exists
                    targetFile.parentFile?.mkdirs()

                    val content = operation.content ?: byteArrayOf()
                    targetFile.writeBytes(content)
                }
            }
            "update" -> {
                if (!operation.isDirectory && operation.content != null) {
                    targetFile.writeBytes(operation.content)
                }
            }
            "delete" -> {
                if (targetFile.exists()) {
                    if (targetFile.isDirectory) {
                        targetFile.deleteRecursively()
                    } else {
                        targetFile.delete()
                    }
                }
            }
        }
    }
}
